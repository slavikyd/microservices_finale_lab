# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: ws-requests.sql
from typing import AsyncIterator, Iterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from db import models


CHAN_LIST_BY_USER_ID = """-- name: chan_list_by_user_id \\:many
SELECT "channel"."id", "channel"."channel", "channel"."title", "channel"."default"
FROM "public"."channel"
JOIN "public"."user_channel" ON "user_channel"."chan_id" = "channel"."id"
WHERE "user_channel"."user_id"=:p1
"""


CREATE_USER = """-- name: create_user \\:exec
INSERT INTO "public"."user"
("id", "username", "given_name", "family_name", "enabled")
VALUES(:p1, :p2, :p3, :p4, :p5)
"""


GET_USER_BY_ID = """-- name: get_user_by_id \\:one
SELECT "id", "username", "given_name", "family_name", "enabled"
FROM "public"."user"
WHERE "id"=:p1
"""


SUBSCRIBE_USER_TO_CHANNEL = """-- name: subscribe_user_to_channel \\:exec
INSERT INTO user_channel (user_id, chan_id, can_publish)
SELECT :p1, c.id, :p3
FROM channel c
WHERE c.channel = :p2
ON CONFLICT (user_id, chan_id) DO NOTHING
"""


USER_CAN_PUBLISH = """-- name: user_can_publish \\:one
SELECT EXISTS (
    SELECT 1 
    FROM "public"."channel" c
    JOIN "public"."user_channel" uc ON uc."chan_id" = c."id" AND uc."user_id" = :p1
    WHERE c."id" = :p2 
    AND uc."can_publish" = true
) AS "can_publish"
"""


USER_CAN_SUBSCRIBE = """-- name: user_can_subscribe \\:one
SELECT EXISTS (
    SELECT 1 
    FROM "public"."channel" c
    LEFT JOIN "public"."user_channel" uc ON uc."chan_id" = c."id" AND uc."user_id" = :p1
    WHERE c."id" = :p2 
    AND (uc."can_subscribe" = true OR (uc."user_id" IS NULL AND c."default" = true))
) AS "can_subscribe"
"""


USER_LIST_BY_CHAN_ID = """-- name: user_list_by_chan_id \\:many
SELECT "user"."id", "user"."username", "user"."given_name", "user"."family_name", "user"."enabled"
FROM "public"."user"
JOIN "public"."user_channel" ON "user_channel"."user_id" = "user"."id"
WHERE "user_channel"."chan_id"=:p1
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def chan_list_by_user_id(self, *, user_id: uuid.UUID) -> Iterator[models.Channel]:
        result = self._conn.execute(sqlalchemy.text(CHAN_LIST_BY_USER_ID), {"p1": user_id})
        for row in result:
            yield models.Channel(
                id=row[0],
                channel=row[1],
                title=row[2],
                default=row[3],
            )

    def create_user(self, *, id: uuid.UUID, username: str, given_name: str, family_name: str, enabled: bool) -> None:
        self._conn.execute(sqlalchemy.text(CREATE_USER), {
            "p1": id,
            "p2": username,
            "p3": given_name,
            "p4": family_name,
            "p5": enabled,
        })

    def get_user_by_id(self, *, id: uuid.UUID) -> Optional[models.User]:
        row = self._conn.execute(sqlalchemy.text(GET_USER_BY_ID), {"p1": id}).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            username=row[1],
            given_name=row[2],
            family_name=row[3],
            enabled=row[4],
        )

    def subscribe_user_to_channel(self, *, user_id: uuid.UUID, channel: str, can_publish: bool) -> None:
        self._conn.execute(sqlalchemy.text(SUBSCRIBE_USER_TO_CHANNEL), {"p1": user_id, "p2": channel, "p3": can_publish})

    def user_can_publish(self, *, user_id: uuid.UUID, id: int) -> Optional[bool]:
        row = self._conn.execute(sqlalchemy.text(USER_CAN_PUBLISH), {"p1": user_id, "p2": id}).first()
        if row is None:
            return None
        return row[0]

    def user_can_subscribe(self, *, user_id: uuid.UUID, id: int) -> Optional[bool]:
        row = self._conn.execute(sqlalchemy.text(USER_CAN_SUBSCRIBE), {"p1": user_id, "p2": id}).first()
        if row is None:
            return None
        return row[0]



    def user_list_by_chan_id(self, *, chan_id: int) -> Iterator[models.User]:
        result = self._conn.execute(sqlalchemy.text(USER_LIST_BY_CHAN_ID), {"p1": chan_id})
        for row in result:
            yield models.User(
                id=row[0],
                username=row[1],
                given_name=row[2],
                family_name=row[3],
                enabled=row[4],
            )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def chan_list_by_user_id(self, *, user_id: uuid.UUID) -> AsyncIterator[models.Channel]:
        result = await self._conn.stream(sqlalchemy.text(CHAN_LIST_BY_USER_ID), {"p1": user_id})
        async for row in result:
            yield models.Channel(
                id=row[0],
                channel=row[1],
                title=row[2],
                default=row[3],
            )

    async def create_user(self, *, id: uuid.UUID, username: str, given_name: str, family_name: str, enabled: bool) -> None:
        await self._conn.execute(sqlalchemy.text(CREATE_USER), {
            "p1": id,
            "p2": username,
            "p3": given_name,
            "p4": family_name,
            "p5": enabled,
        })

    async def get_user_by_id(self, *, id: uuid.UUID) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            username=row[1],
            given_name=row[2],
            family_name=row[3],
            enabled=row[4],
        )

    async def subscribe_user_to_channel(self, *, user_id: uuid.UUID, channel: str, can_publish: bool) -> None:
        await self._conn.execute(sqlalchemy.text(SUBSCRIBE_USER_TO_CHANNEL), {"p1": user_id, "p2": channel, "p3": can_publish})

    async def user_can_publish(self, *, user_id: uuid.UUID, id: int) -> Optional[bool]:
        row = (await self._conn.execute(sqlalchemy.text(USER_CAN_PUBLISH), {"p1": user_id, "p2": id})).first()
        if row is None:
            return None
        return row[0]

    async def user_can_subscribe(self, *, user_id: uuid.UUID, id: int) -> Optional[bool]:
        row = (await self._conn.execute(sqlalchemy.text(USER_CAN_SUBSCRIBE), {"p1": user_id, "p2": id})).first()
        if row is None:
            return None
        return row[0]

    async def user_list_by_chan_id(self, *, chan_id: int) -> AsyncIterator[models.User]:
        result = await self._conn.stream(sqlalchemy.text(USER_LIST_BY_CHAN_ID), {"p1": chan_id})
        async for row in result:
            yield models.User(
                id=row[0],
                username=row[1],
                given_name=row[2],
                family_name=row[3],
                enabled=row[4],
            )